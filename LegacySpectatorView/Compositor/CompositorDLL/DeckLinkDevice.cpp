/* -LICENSE-START-
** Copyright (c) 2013 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
#include "stdafx.h"

#if USE_DECKLINK || USE_DECKLINK_SHUTTLE

#include <comutil.h>
#include "DeckLinkDevice.h"

using namespace std;


DeckLinkDevice::DeckLinkDevice(IDeckLink* device) :
    m_deckLink(device),
    m_deckLinkInput(NULL),
    m_deckLinkOutput(NULL),
    m_supportsFormatDetection(false),
    m_refCount(1),
    m_currentlyCapturing(false),
    m_playbackTimeScale(600)
{
    if (m_deckLink != NULL)
    {
        m_deckLink->AddRef();
    }

    InitializeCriticalSection(&m_captureCardCriticalSection);
    InitializeCriticalSection(&m_frameAccessCriticalSection);
    InitializeCriticalSection(&m_outputCriticalSection);
}

DeckLinkDevice::~DeckLinkDevice()
{
    StopCapture();

    if (m_deckLinkInput != NULL)
    {
        m_deckLinkInput->Release();
        m_deckLinkInput = NULL;
    }

    if (supportsOutput && m_deckLinkOutput != NULL)
    {
        m_deckLinkOutput->Release();
        m_deckLinkOutput = NULL;
    }

    if (m_deckLink != NULL)
    {
        m_deckLink->Release();
        m_deckLink = NULL;
    }

    DeleteCriticalSection(&m_captureCardCriticalSection);
    DeleteCriticalSection(&m_outputCriticalSection);
    DeleteCriticalSection(&m_frameAccessCriticalSection);

    delete[] thirdCachedBuffer;
    delete[] secondCachedBuffer;
    delete[] latestBuffer;
    delete[] stagingBuffer;
    delete[] outputBuffer;
    delete[] outputBufferRaw;
}

HRESULT    STDMETHODCALLTYPE DeckLinkDevice::QueryInterface(REFIID iid, LPVOID *ppv)
{
    HRESULT result = E_NOINTERFACE;

    if (ppv == NULL)
    {
        return E_INVALIDARG;
    }

    // Initialise the return result
    *ppv = NULL;

    // Obtain the IUnknown interface and compare it the provided REFIID
    if (iid == IID_IUnknown)
    {
        *ppv = this;
        AddRef();
        result = S_OK;
    }
    else if (iid == IID_IDeckLinkInputCallback)
    {
        *ppv = (IDeckLinkInputCallback*)this;
        AddRef();
        result = S_OK;
    }
    else if (iid == IID_IDeckLinkNotificationCallback)
    {
        *ppv = (IDeckLinkNotificationCallback*)this;
        AddRef();
        result = S_OK;
    }

    return result;
}

ULONG STDMETHODCALLTYPE DeckLinkDevice::AddRef(void)
{
    return InterlockedIncrement((LONG*)&m_refCount);
}

ULONG STDMETHODCALLTYPE DeckLinkDevice::Release(void)
{
    int newRefValue;

    newRefValue = InterlockedDecrement((LONG*)&m_refCount);
    if (newRefValue == 0)
    {
        delete this;
        return 0;
    }

    return newRefValue;
}

bool DeckLinkDevice::Init(ID3D11ShaderResourceView* colorSRV, ID3D11Texture2D* outputTexture, bool useCPU, bool passthroughOutput)
{
    IDeckLinkAttributes*            deckLinkAttributes = NULL;
    IDeckLinkDisplayModeIterator*   displayModeIterator = NULL;
    IDeckLinkDisplayMode*           displayMode = NULL;
    BSTR                            deviceNameBSTR = NULL;

    ZeroMemory(rawBuffer, FRAME_BUFSIZE_RAW);
    ZeroMemory(thirdCachedBuffer, FRAME_BUFSIZE);
    ZeroMemory(secondCachedBuffer, FRAME_BUFSIZE);
    ZeroMemory(latestBuffer, FRAME_BUFSIZE);
    ZeroMemory(outputBuffer, FRAME_BUFSIZE);
    ZeroMemory(outputBufferRaw, FRAME_BUFSIZE_RAW);

    _useCPU = useCPU;
    _passthroughOutput = passthroughOutput;

    _colorSRV = colorSRV;
    _outputTexture = outputTexture;

    if (colorSRV != nullptr)
    {
        colorSRV->GetDevice(&device);
    }

    // Get input interface
    if (m_deckLink->QueryInterface(IID_IDeckLinkInput, (void**)&m_deckLinkInput) != S_OK)
        return false;

    if (m_deckLink->QueryInterface(IID_IDeckLinkOutput, (void**)&m_deckLinkOutput) != S_OK)
    {
        supportsOutput = false;
        // Returning false here prevent the rest of the init function executing
        // But we can still continue without an output interface
    }

    // Check if input mode detection is supported.
    if (m_deckLink->QueryInterface(IID_IDeckLinkAttributes, (void**)&deckLinkAttributes) == S_OK)
    {
        if (deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &m_supportsFormatDetection) != S_OK)
        {
            m_supportsFormatDetection = false;
        }

        deckLinkAttributes->Release();
    }

    return true;
}

bool DeckLinkDevice::StartCapture(BMDDisplayMode videoDisplayMode)
{
    if (m_deckLinkInput == NULL)
    {
        return false;
    }

    OutputDebugString(L"Start Capture.\n");
    BMDVideoInputFlags videoInputFlags = bmdVideoInputFlagDefault;
    BMDVideoOutputFlags videoOutputFlags = bmdVideoOutputFlagDefault;

    // Enable input video mode detection if the device supports it
    if (m_supportsFormatDetection == TRUE)
    {
        videoInputFlags |= bmdVideoInputEnableFormatDetection;
    }

    // Set capture callback
    m_deckLinkInput->SetCallback(this);

    // Set the video input mode
    if (m_deckLinkInput->EnableVideoInput(videoDisplayMode, bmdFormat8BitYUV, videoInputFlags) != S_OK)
    {
        OutputDebugString(L"Unable to set the chosen video mode.\n");
        return false;
    }

    if (supportsOutput && m_deckLinkOutput != NULL && m_deckLinkOutput->EnableVideoOutput(videoDisplayMode, videoOutputFlags) != S_OK)
    {
        OutputDebugString(L"Unable to set video output.\n");
        supportsOutput = false;
    }

    if (supportsOutput && m_deckLinkOutput != NULL && m_deckLinkOutput->StartScheduledPlayback(0, m_playbackTimeScale, 1.0) != S_OK)
    {
        OutputDebugString(L"Unable to start output playback.\n");
        supportsOutput = false;
    }

    // Start the capture
    if (m_deckLinkInput->StartStreams() != S_OK)
    {
        OutputDebugString(L"Unable to start capture.\n");
        return false;
    }

    m_currentlyCapturing = true;

    return true;
}

void DeckLinkDevice::StopCapture()
{
    EnterCriticalSection(&m_captureCardCriticalSection);

    OutputDebugString(L"Stop Capture.\n");

    if (m_deckLinkInput != NULL)
    {
        // Stop the capture
        m_deckLinkInput->StopStreams();

        // Delete capture callback
        m_deckLinkInput->SetCallback(NULL);
    }

    if (supportsOutput && m_deckLinkOutput != NULL)
    {
        m_deckLinkOutput->StopScheduledPlayback(0, NULL, 0);
        m_deckLinkOutput->DisableVideoOutput();
    }

    m_currentlyCapturing = false;
    LeaveCriticalSection(&m_captureCardCriticalSection);
}

HRESULT DeckLinkDevice::VideoInputFormatChanged(/* in */ BMDVideoInputFormatChangedEvents notificationEvents, /* in */ IDeckLinkDisplayMode *newMode, /* in */ BMDDetectedVideoInputFormatFlags detectedSignalFlags)
{
    EnterCriticalSection(&m_captureCardCriticalSection);
    EnterCriticalSection(&m_outputCriticalSection);

    OutputDebugString(L"Changing Formats to: ");
    OutputDebugString(std::to_wstring(newMode->GetDisplayMode()).c_str());
    OutputDebugString(L"\n");

    // If we do not have the correct dimension frames - loop until user changes camera settings.
    if (newMode->GetWidth() != FRAME_WIDTH || newMode->GetHeight() != FRAME_HEIGHT)
    {
        OutputDebugString(L"Invalid frame dimensions detected.\n");
        OutputDebugString(L"Actual Frame Dimensions: ");
        OutputDebugString(std::to_wstring(newMode->GetWidth()).c_str());
        OutputDebugString(L", ");
        OutputDebugString(std::to_wstring(newMode->GetHeight()).c_str());
        OutputDebugString(L"\n");

        OutputDebugString(L"Expected Frame Dimensions: ");
        OutputDebugString(std::to_wstring(FRAME_WIDTH).c_str());
        OutputDebugString(L", ");
        OutputDebugString(std::to_wstring(FRAME_HEIGHT).c_str());
        OutputDebugString(L"\n");

        LeaveCriticalSection(&m_captureCardCriticalSection);
        LeaveCriticalSection(&m_outputCriticalSection);
        return E_PENDING;
    }

    pixelFormat = PixelFormat::YUV;
    BMDPixelFormat bmdPixelFormat = bmdFormat8BitYUV;

    if ((detectedSignalFlags & bmdDetectedVideoInputRGB444) != 0)
    {
        pixelFormat = PixelFormat::BGRA;
        bmdPixelFormat = bmdFormat8BitBGRA;
    }

    // Stop the capture
    m_currentlyCapturing = false;

    m_deckLinkInput->StopStreams();
    m_deckLinkInput->FlushStreams();

    if (supportsOutput && m_deckLinkOutput != NULL)
    {
        m_deckLinkOutput->StopScheduledPlayback(0, NULL, 0);
        m_deckLinkOutput->DisableVideoOutput();
    }

    // Set the video input mode
    if (m_deckLinkInput->EnableVideoInput(newMode->GetDisplayMode(), bmdPixelFormat, bmdVideoInputEnableFormatDetection) != S_OK)
    {
        OutputDebugString(L"Could not enable video input when restarting capture with detected input.\n");
        goto bail;
    }

    // Start the capture
    if (m_deckLinkInput->StartStreams() != S_OK)
    {
        OutputDebugString(L"Could not start streams when restarting capture with detected input.\n");
        goto bail;
    }

    if (m_deckLinkOutput != NULL && m_deckLinkOutput->EnableVideoOutput(newMode->GetDisplayMode(), bmdVideoOutputFlagDefault) != S_OK)
    {
        OutputDebugString(L"Unable to set video output.\n");
        supportsOutput = false;
    }

    m_currentlyCapturing = true;

bail:
    OutputDebugString(L"Done changing formats.\n");

    LeaveCriticalSection(&m_captureCardCriticalSection);
    LeaveCriticalSection(&m_outputCriticalSection);
    return S_OK;
}

HRESULT DeckLinkDevice::VideoInputFrameArrived(/* in */ IDeckLinkVideoInputFrame* frame, /* in */ IDeckLinkAudioInputPacket* audioPacket)
{
    LARGE_INTEGER time;
    QueryPerformanceCounter(&time);

    if (frame == nullptr)
    {
        return S_OK;
    }

    BMDPixelFormat framePixelFormat = frame->GetPixelFormat();

    EnterCriticalSection(&m_captureCardCriticalSection);

    //TODO: Create conversion to RGBA for any other pixel format your camera outputs at.
    if (framePixelFormat == BMDPixelFormat::bmdFormat8BitYUV)
    {
        if (frame->GetBytes((void**)&rawBuffer) == S_OK)
        {
            // Always return the latest buffer when using the CPU.
            if (_useCPU)
            {
                DirectXHelper::ConvertYUVtoBGRA(rawBuffer, latestBuffer, FRAME_WIDTH, FRAME_HEIGHT, true);
            }
            else
            {
                memcpy(thirdCachedBuffer, secondCachedBuffer, FRAME_BUFSIZE_RAW);
                memcpy(secondCachedBuffer, latestBuffer, FRAME_BUFSIZE_RAW);
                memcpy(latestBuffer, rawBuffer, FRAME_BUFSIZE_RAW);
            }
        }
    }
    else if (framePixelFormat == BMDPixelFormat::bmdFormat8BitBGRA)
    {
        if (frame->GetBytes((void**)&localFrameBuffer) == S_OK)
        {
            if (_useCPU)
            {
                //TODO: Remove this block if R and B components are swapped in color feed.
                memcpy(stagingBuffer, localFrameBuffer, FRAME_BUFSIZE);
                DirectXHelper::ConvertBGRAtoRGBA(stagingBuffer, FRAME_WIDTH, FRAME_HEIGHT, true);
                // Do not cache frames when using the CPU
                memcpy(latestBuffer, stagingBuffer, FRAME_BUFSIZE);
            }
            else
            {
                memcpy(thirdCachedBuffer, secondCachedBuffer, FRAME_BUFSIZE);
                memcpy(secondCachedBuffer, latestBuffer, FRAME_BUFSIZE);
                memcpy(latestBuffer, localFrameBuffer, FRAME_BUFSIZE);
            }
        }
    }

    LONGLONG t;
    frame->GetStreamTime(&t, &frameDuration, QPC_MULTIPLIER);

    // Get frame time.
    thirdTimeStamp = secondTimeStamp;
    secondTimeStamp = latestTimeStamp;
    latestTimeStamp = time.QuadPart;

    dirtyFrame = false;

    if (supportsOutput && m_deckLinkOutput != NULL)
    {
        BMDTimeValue bmd_time, bmd_duration;
        frame->GetStreamTime(&bmd_time, &bmd_duration, m_playbackTimeScale);

        if (_passthroughOutput)
        {
            if (supportsOutput && m_deckLinkOutput != NULL)
            {
                m_deckLinkOutput->DisplayVideoFrameSync(frame);
            }
        }
        else if (_outputTexture != nullptr)
        {
            if (framePixelFormat == BMDPixelFormat::bmdFormat8BitYUV)
            {
                memcpy(rawBuffer, outputBufferRaw, FRAME_BUFSIZE_RAW);
            }
            else if (framePixelFormat == BMDPixelFormat::bmdFormat8BitBGRA)
            {
                memcpy(localFrameBuffer, outputBuffer, FRAME_BUFSIZE);
            }

            m_deckLinkOutput->DisplayVideoFrameSync(frame);

            // Clear frame buffer.
            if (framePixelFormat == BMDPixelFormat::bmdFormat8BitYUV)
            {
                ZeroMemory(rawBuffer, FRAME_BUFSIZE_RAW);
            }
            else if (framePixelFormat == BMDPixelFormat::bmdFormat8BitBGRA)
            {
                ZeroMemory(localFrameBuffer, FRAME_BUFSIZE);
            }
        }
    }

    LeaveCriticalSection(&m_captureCardCriticalSection);

    return S_OK;
}

void DeckLinkDevice::Update()
{
    if (_colorSRV != nullptr &&
        device != nullptr)
    {
        if (!dirtyFrame)
        {
            dirtyFrame = true;
            if (_useCPU && latestBuffer != nullptr)
            {
                // Do not cache when using CPU.
                DirectXHelper::UpdateSRV(device, _colorSRV, latestBuffer, FRAME_WIDTH * FRAME_BPP);
            }
            else if (!_useCPU && thirdCachedBuffer != nullptr)
            {
                DirectXHelper::UpdateSRV(device, _colorSRV, thirdCachedBuffer, FRAME_WIDTH * FRAME_BPP);
            }

            EnterCriticalSection(&m_frameAccessCriticalSection);
            isVideoFrameReady = true;
            LeaveCriticalSection(&m_frameAccessCriticalSection);

            if (supportsOutput && device != nullptr && _outputTexture != nullptr)
            {
                EnterCriticalSection(&m_outputCriticalSection);
                if (pixelFormat == PixelFormat::YUV)
                {
                    DirectXHelper::GetBytesFromTexture(device, _outputTexture, FRAME_BPP_RAW, outputBufferRaw);
                }
                else if (pixelFormat == PixelFormat::BGRA)
                {
                    DirectXHelper::GetBytesFromTexture(device, _outputTexture, FRAME_BPP, outputBuffer);
                }
                LeaveCriticalSection(&m_outputCriticalSection);
            }
        }
    }
}

bool DeckLinkDevice::OutputYUV()
{
    return (pixelFormat == PixelFormat::YUV);
}

bool DeckLinkDevice::IsVideoFrameReady()
{
    EnterCriticalSection(&m_frameAccessCriticalSection);
    bool ret = isVideoFrameReady;
    if (isVideoFrameReady)
    {
        isVideoFrameReady = false;
    }
    LeaveCriticalSection(&m_frameAccessCriticalSection);

    return ret;
}

DeckLinkDeviceDiscovery::DeckLinkDeviceDiscovery()
    : m_deckLinkDiscovery(NULL), m_refCount(1)
{
    if (CoCreateInstance(CLSID_CDeckLinkDiscovery, NULL, CLSCTX_ALL, IID_IDeckLinkDiscovery, (void**)&m_deckLinkDiscovery) != S_OK)
    {
        m_deckLinkDiscovery = NULL;
    }
}

DeckLinkDeviceDiscovery::~DeckLinkDeviceDiscovery()
{
    if (m_deckLinkDiscovery != NULL)
    {
        // Uninstall device arrival notifications and release discovery object
        m_deckLinkDiscovery->UninstallDeviceNotifications();
        m_deckLinkDiscovery->Release();
        m_deckLinkDiscovery = NULL;
    }

    if (m_deckLink != nullptr)
    {
        m_deckLink->Release();
        m_deckLink = NULL;
    }
}

bool DeckLinkDeviceDiscovery::Enable()
{
    HRESULT result = E_FAIL;

    // Install device arrival notifications
    if (m_deckLinkDiscovery != NULL)
    {
        result = m_deckLinkDiscovery->InstallDeviceNotifications(this);
    }

    return result == S_OK;
}

void DeckLinkDeviceDiscovery::Disable()
{
    // Uninstall device arrival notifications
    if (m_deckLinkDiscovery != NULL)
    {
        m_deckLinkDiscovery->UninstallDeviceNotifications();
    }
}

HRESULT DeckLinkDeviceDiscovery::DeckLinkDeviceArrived(/* in */ IDeckLink* deckLink)
{
    if (m_deckLink == nullptr)
    {
        deckLink->AddRef();

        m_deckLink = deckLink;
    }

    return S_OK;
}

HRESULT DeckLinkDeviceDiscovery::DeckLinkDeviceRemoved(/* in */ IDeckLink* deckLink)
{
    deckLink->Release();
    return S_OK;
}

HRESULT    STDMETHODCALLTYPE DeckLinkDeviceDiscovery::QueryInterface(REFIID iid, LPVOID *ppv)
{
    HRESULT result = E_NOINTERFACE;

    if (ppv == NULL)
    {
        return E_INVALIDARG;
    }

    // Initialise the return result
    *ppv = NULL;

    // Obtain the IUnknown interface and compare it the provided REFIID
    if (iid == IID_IUnknown)
    {
        *ppv = this;
        AddRef();
        result = S_OK;
    }
    else if (iid == IID_IDeckLinkDeviceNotificationCallback)
    {
        *ppv = (IDeckLinkDeviceNotificationCallback*)this;
        AddRef();
        result = S_OK;
    }

    return result;
}

ULONG STDMETHODCALLTYPE DeckLinkDeviceDiscovery::AddRef(void)
{
    return InterlockedIncrement((LONG*)&m_refCount);
}

ULONG STDMETHODCALLTYPE DeckLinkDeviceDiscovery::Release(void)
{
    ULONG newRefValue;

    newRefValue = InterlockedDecrement((LONG*)&m_refCount);
    if (newRefValue == 0)
    {
        delete this;
        return 0;
    }

    return newRefValue;
}

#endif
